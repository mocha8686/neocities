---
import { type AstroComponentFactory } from 'astro/runtime/server/index.js';
import type { HTMLAttributes, HTMLTag } from 'astro/types';

export interface ItemBody {
	name: string;
	description?: string;
	as?: HTMLTag | AstroComponentFactory;
	props?: Record<string, unknown>;
}

export type Header = string | { level: number; body: string };

export type Node<T> = T | { body: T; children: Node<T>[] };

export type Item = Node<ItemBody>;

type Levels = boolean[];

interface Props extends HTMLAttributes<'ul'> {
	header?: Header;
	items: Item[];
	levels?: Levels;
}

const { header, items, levels = [], class: className, ...rest } = Astro.props;

const bars = levels.map((isActive) => (isActive ? '│ ' : '  ')).join('');

const HeaderTag =
	typeof header === 'string' || !header?.level ? 'h3' : `h${header.level}`;
const headerBody =
	(header && (typeof header === 'string' ? header : header.body)) || '';

const prefix = `"${bars}├─/"`;
const endPrefix = `"${bars}└─/"`;

function processLevels(levels: Levels, last: boolean): Levels {
	const newLevels = [...levels, !last];
	return newLevels;
}

export function itemIsLeaf<Body extends {}>(item: Node<Body>): item is Body {
	return typeof item !== 'object' || !('children' in item);
}
---

<>
	{/* @ts-ignore Werid Astro funk */}
	{levels.length === 0 && <HeaderTag class="header">/{headerBody}</HeaderTag>}
	<ul class:list={[className, { root: levels.length === 0 }]} {...rest}>
		{
			items.map((item, i) => {
				let body: ItemBody;
				if (itemIsLeaf(item)) {
					body = item;
				} else {
					body = item.body;
				}

				const Tag = body.as ?? Fragment;
				const isLast = i + 1 === items.length;

				// @ts-ignore Props type is hard here
				const { class: className, ...rest } = body.props;

				return (
					<li data-last={isLast}>
						<Tag class:list={[className, 'name']} {...rest}>
							{body.name}
						</Tag>
						{body.description && (
							<p class="description">{body.description}</p>
						)}
						{!itemIsLeaf(item) && (
							<Astro.self
								items={item.children}
								levels={processLevels(levels, isLast)}
							/>
						)}
					</li>
				);
			})
		}
	</ul>
</>

<style define:vars={{ prefix, 'end-prefix': endPrefix }}>
	.header {
		margin-block-end: 0.25rem;
		padding-inline-start: 0.5ch;
	}

	ul {
		padding-inline-start: 2ch;
		font-family: var(--ff-mono);
		line-height: 1.3;
		list-style-type: var(--prefix);
	}

	ul:not(:only-child) {
		margin-block-start: 0;
	}

	li {
		position: relative;
	}

	.description {
		position: absolute;
		inset-block: 0;
		inset-inline-end: 0;
		margin: 0;
		color: var(--cl-secondary);
	}

	.description::before {
		content: '# ';
	}

	li[data-last='true'] {
		list-style-type: var(--end-prefix);
	}
</style>
