---
import type { GetStaticPaths } from 'astro';
import { render } from 'astro:content';
import { getCollection } from 'astro:content';

import type { Heading } from '$src/components/cryptopals/Heading';
import HeadingList from '$src/components/cryptopals/HeadingList.astro';
import CryptopalsLayout from '$src/layouts/CryptopalsLayout.astro';

export const getStaticPaths = (async () => {
	const sets = await getCollection('cryptopals');
	return sets.map(set => ({
		params: { set: set.id },
		props: { set },
	}));
}) satisfies GetStaticPaths;

const { set } = Astro.props;
const { Content, headings } = await render(set);

const challengeHeadings = headings.reduce<Heading[]>(
	(acc: Heading[], heading) => {
		function getArrayAtDepth(arr: Heading[], depth: number): Heading[] {
			const heading = arr.at(-1);

			if (!heading || heading.depth === depth) return arr;

			if (!heading.children) {
				if (heading.depth !== depth - 1) {
					throw new Error(
						`Invalid heading nesting (found h${depth} under h${heading.depth})`,
					);
				}

				heading.children = [];
				return heading.children;
			} else {
				return getArrayAtDepth(heading.children, depth);
			}
		}

		const arr = getArrayAtDepth(acc, heading.depth);
		arr.push({
			href: `#${heading.slug}`,
			text: heading.text,
			depth: heading.depth,
		});
		return acc;
	},
	[],
);
---

<CryptopalsLayout>
	<header>
		<h1>Set {set.data.number} â€” {set.data.title}</h1>
		<p>{set.data.description}</p>
	</header>

	<main>
		<nav x-data>
			<h2>Challenges</h2>
			<HeadingList headings={challengeHeadings} />
		</nav>

		<Content />
	</main>
</CryptopalsLayout>

<script>
	import Alpine from 'alpinejs';

	type StateEntry = {
		value: string;
		isActive: boolean;
	};
	const initial: StateEntry[] = [];

	const state = {
		entries: initial,

		get active(): string | undefined {
			return this.entries.at(-1)?.value;
		},

		set active(value: string) {
			this.entries.push({ value, isActive: true });
			this.prune();
		},

		inactive(value: string) {
			const entry = this.entries.find(s => s.value === value);
			if (entry) {
				entry.isActive = false;
				this.prune();
			}
		},

		prune() {
			const arr = this.entries.filter(s => s.isActive && s.value.length > 0);
			if (arr.length > 0) {
				this.entries = arr;
			}
		},
	};
	type Heading = typeof state;

	Alpine.store('heading', state);

	const callback = (entries: IntersectionObserverEntry[]) => {
		for (const entry of entries) {
			const heading: Heading = Alpine.store('heading');
			if (entry.isIntersecting) {
				heading.active = entry.target.id;
			} else {
				heading.inactive(entry.target.id);
			}
		}
	};

	const observer = new IntersectionObserver(callback);
	const headings = document.querySelectorAll('h2, h3, h4, h5, h6');
	for (const heading of headings) {
		observer.observe(heading);
	}
</script>

<style is:global>
	:root {
		scroll-behavior: smooth;
	}

	main {
		--content-width: 75ch;
		--nav-width: 12rem;
		--gap: 2rem;

		position: relative;

		container-type: inline-size;
		display: grid;
		grid-template-columns:
			[full-width-start] 0 [content-start] minmax(auto, var(--content-width))
			[content-end] auto [full-width-end] var(--gap) [nav-start] minmax(
				min(var(--nav-width), 100%),
				1fr
			)
			[nav-end];

		line-height: 1.8;

		> * {
			grid-column: content;
		}

		> :nth-child(2) {
			counter-reset: challenge;
		}

		h2,
		h3,
		h4,
		h5,
		h6 {
			scroll-margin-block-start: 1em;
		}

		> h2 {
			display: flex;
			grid-column: full-width;
			border-block-end: 2px solid var(--cl-accent);

			&::before {
				content: counter(challenge);
				counter-increment: challenge;

				display: block;
				flex: 0 3.2ex;

				aspect-ratio: 1;
				margin-inline-end: 0.5em;
				padding: 0 1ch;

				color: var(--cl-on-accent);

				background: var(--cl-accent);
			}

			+ blockquote {
				padding-inline-start: 1em;
				padding-inline-end: 0.5em;
				border-inline-start: 0.4em solid var(--cl-accent);

				font-style: italic;

				background: var(--cl-container);

				li {
					line-height: 1.5;

					& + & {
						margin-block-start: 0.5em;
					}
				}
			}
		}

		> p {
			& + & {
				margin-block-start: 0;
			}

			@container (width < 800px) {
				line-height: 1.6;
			}
		}

		> details {
			padding-inline-start: 1em;
			border-inline-start: 0.4em solid var(--cl-accent);
			background: var(--cl-container);

			summary {
				padding-block: 0.5em;
				font-size: 1.25rem;
				font-weight: bold;

				&::after {
					content: '';

					display: inline-block;

					aspect-ratio: 1;
					width: 1.25em;
					margin-inline-start: 0.25em;

					vertical-align: text-bottom;

					background-color: var(--cl-accent);

					mask-image: url('/src/assets/icons/info.svg');
					mask-repeat: no-repeat;
					mask-size: 100% 100%;
				}
			}
		}

		> nav {
			position: sticky;
			inset-block-start: 20%;

			grid-column: nav;
			grid-row: span 9999;
			align-self: start;
			justify-self: center;

			h2 {
				padding-inline-end: 4em;
				border-block-end: 2px solid var(--cl-accent);
			}
		}

		@media screen and (width <= 1000px) {
			grid-template-columns:
				[full-width-start] 0 [content-start] minmax(auto, var(--content-width))
				[content-end] auto [full-width-end];

			> nav {
				display: none;
			}
		}
	}

	.astro-code {
		padding: 0.5em 2ch;
	}

	.astro-code,
	.astro-code span {
		font-family: var(--ff-code);
	}

	pre.astro-code {
		counter-reset: code-line;
	}

	.astro-code:not([data-language='plaintext']) .line {
		&::before {
			content: counter(code-line);
			counter-increment: code-line;
			margin-inline-end: 2ch;
			opacity: 0.5;
		}

		&:nth-child(-n + 9)::before {
			content: ' ' counter(code-line);
		}
	}

	.astro-code[data-language='plaintext'] {
		line-height: 1.1;
	}
</style>
